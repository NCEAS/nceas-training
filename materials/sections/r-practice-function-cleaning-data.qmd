## Learning Objectives {.unnumbered}

-   Integrate knowledge on writing functions in R
-   Understand how functions can be used when cleaning data


## About the data {.unnumbered}

For this practice session we will use data on shorebird breeding ecology collected in Utqiaġvik, Alaska, 2003-2018 by Richard Lanctot and Sarah Saalfeld. This data is publicly available at the Arctic Data Center.

-   [Richard Lanctot and Sarah Saalfeld. 2019. Utqiaġvik shorebird breeding ecology study, Utqiaġvik, Alaska, 2003-2018. Arctic Data Center. doi:10.18739/A23R0PT35](https://doi.org/10.18739/A23R0PT35)


One of the features if this dataset is that it has many files with similar formatting, most of which contain the column `species` which is comprised of the [Bird Banding Laboratory species codes](https://www.usgs.gov/labs/bird-banding-laboratory/science/understanding-bbl-codes). These four letter codes aren't very intuitive to most people, so the main goal for this session is to write a function that can be used on any file in this dataset that contains a species code.


::: callout-tip
### Setup

0. Make sure you’re in the right project (`training_{USERNAME}`) and use the Git workflow by `Pull`ing to check for any changes in the remote repository (aka repository on GitHub). 
1. Create a new Quarto Document.
    a. Title it “R Practice: Functions”.
    b. Save the file and name it “r-practice-functions”.

2.  Insert a Setup r chunck and load the necessary libraries. Note here we introduce a new package called `rvest`. This package enables easy scraping and handling of information from websites.

```{r message=FALSE, warning=FALSE}
library(rvest)
library(readr)
library(dplyr)
library(janitor)
```

3. Load the species table using the following code. This code scrapes a table from a url and uses some cleaning and wrangling functions to get the table into our Environement in the format we want.

```{r}
webpage <- rvest::read_html("https://www.pwrc.usgs.gov/BBL/Bander_Portal/login/speclist.php")

tbls <- rvest::html_nodes(webpage, "table") %>% 
    rvest::html_table(fill = TRUE)

species <- tbls[[1]] %>% 
    janitor::clean_names() %>% 
    select(alpha_code, common_name) %>% 
    mutate(alpha_code = tolower(alpha_code))
```

4.  Obtain data from the the Arctic Data Center [Utqiaġvik shorebird breeding ecology study, Utqiaġvik](https://doi.org/10.18739/A23R0PT35). Download the following files:

    -   `Utqiagvik_adult_shorebird_banding.csv`
    -   `Utqiagvik_chick_shorebird_banding.csv`
    
**Note:** It's up to you on how you want to download and load the data! You can either use the download links (obtain by right-clicking the "Download" button and select "Copy Link Address" for each data entity) or manually download the data and then upload the files to RStudio server.

5. Use the Git workflow. After you’ve set up your project and uploaded your data go through the workflow: ```Stage (add) -> Commit -> Pull -> Push```

:::


::: {.callout-caution icon="false"}
## A note on `rvest`
This is a handy package that requires a moderate amount of knowledge of `html` to use. We used it here because we don't have a plain text version of the BBL species codes. Ideally, to build a reproducible and long lived workflow, we would want to run this code and then store a plain text version of the data in a long lived location, which cites the original source appropriately.
:::



## Write a function that will translate species codes into common names.

<!--
EDIT FROM HERE

::: callout-note
### Read and explore data

   fsfsfsf
::: 



::: callout-note
## Write functions to clean species code

 -   **Hint**: The fastest way to do this involves adding a column to the `data.frame`. Your function will have two arguments
    -   **Optional Extra Challenge**: For a little extra challenge, try to incorporate an `if` statement that looks for `NA` values in the common name field you are adding. What other conditionals might you include to make your function smarter?
:::


### Visual schematic of data

Make this:

    year common_name         pred_count
    2003 Glaucous Gull               54
    2003 Parasitic Jaeger             2
    2003 Pomarine Jaeger              6
    2004 Glaucous Gull               69
    2004 Long-tailed Jaeger          13

And then make this:

```
common_name             year total_predated pred_count
American Golden-Plover  2003              4         62
American Golden-Plover  2004             22         93
American Golden-Plover  2005              0         72
American Golden-Plover  2006              0        193
American Golden-Plover  2007             12        154
American Golden-Plover  2008             22        328
American Golden-Plover  2009             92        443
```

REMOVE ARROW BELOW
-->

::: {.callout-caution icon="false"}

## Why do we need to use a function for this task?

You will likely at some point realize that the function we asked you to write is pretty simple. The code can in fact be accomplished in a single line. So why write your own function for this? There are a couple of answers. The first and most obvious is that we want to you practice writing function syntax with simple examples. But there are other reasons why this operation might benefit from a function:

* Follow the DRY principles!
    - If you find yourself doing the same cleaning steps on many of your data files, over and over again, those operations are good candidates for functions. This falls into that category, since we need to do the same transformation on both of the files we use here, and if we incorporated more files from this dataset it would come in even more use.
* Add custom warnings and quality control.
    - Functions allow you to incorporate quality control through conditional statements coupled with warnings. Instead of checking for NA's or duplicated rows after you run a join, you can check within the function and return a warning if any are found.
* Check your function input more carefully
    - Similar to custom warnings, functions allow you to create custom errors too. Writing functions is a good way to incorporate defensive coding practices, where potential issues are looked for and the process is stopped if they are found.

:::



