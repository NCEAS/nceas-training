## Reproducible Survey Workflows 

### Learning Objectives

- Overview of survey instruments


### Introduction

Surveys and questionnaires are commonly used research methods within social science and other fields. For example, understanding regional and national population demographics, income, and education as part of the [National Census](https://www.census.gov/en.html) activity, assessing audience perspectives on specific topics of research interest (e.g. the work by Tenopir and colleagues on [Data Sharing by Scientists](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0021101)), evaluation of learning deliverables and outcomes, and consumer feedback on new and upcoming products. These are distinct from the use of the term survey within natural sciences, which might include geographical surveys ("the making of measurement in the field from which maps are drawn"), ecological surveys ("the process whereby a proposed development site is assess to establish any environmental impact the development may have") or biodiversity surveys ("provide detailed information about biodiversity and community structure") among others.

Although surveys can be conducted on paper or verbally, here we focus on surveys done via software tools. Needs will vary according to the nature of the research being undertaken. However, there is fundamental functionality that survey software should provide including:

1. The ability to create and customize questions
1. The ability to include different types of questions
1. The ability to distribute the survey and manage response collection
1. The ability to collect, summarize, and (securely) store response data

More advanced features can include:

1. **Visual design and templates**  - custom design might include institutional branding or aesthetic elements. Templates allow you to save these designs and apply to other surveys
1. **Question piping** - piping inserts answers from previous questions into upcoming questions and can personalize the survey experience for users 
1. **Survey logic** - with question logic and skip logic you can control the inclusion / exclusion of questions based on previous responses
1. **Randomization** - the ability to randomize the presentation of questions within (blocks of) the survey
1. **Branching** - this allows for different users to take different paths through the survey. Similar to question logic but at a bigger scale
1. **Language support** - automated translation or multi-language presentation support
1. **Shared administration** - enables collaboration on the survey and response analysis 
1. **Survey export** - ability to download (export) the survey instrument
1. **Reports** - survey response visualization and reporting tools
1. **Institutional IRB approved** - institutional IRB policy may require certain software be used for research purposes

Commonly used survey software within academic (vs market) research include Qualtrics, Survey Monkey and Google Forms. Both qualtrics and survey monkey are licensed (with limited functionality available at no cost) and google forms is free.

![](images/survey_comparison.png)

### Building workflows using Qualtrics

In this lesson we will use the [`qualtRics`](https://github.com/ropensci/qualtRics) package to reproducible access some survey results set up for this course. 

First, open a new RMarkdown document and add a chunk to load the libraries we'll need for this lesson:

```{r, eval = FALSE}
library(qualtRics)
library(dplyr)
library(tidyr)
library(knitr)
library(ggplot2)
```

Next, we need to set the API credentials.

```{r, eval = FALSE}
qualtrics_api_credentials(api_key = "", base_url = "ucsb.co1.qualtrics.com", install = TRUE)
```

To get a list of all the surveys in your Qualtrics instance, use the `all_surveys` function.

```{r, eval = FALSE}
surveys <- all_surveys()
```

This function returns a list of surveys, in this case only one, and information about each, including an identifier and it's name. We'll need that identifier later, so let's go ahead and extract it using base R from the data frame.

```{r, eval = FALSE}
i <- which(surveys$name == "Survey for Data Science Training")
id <- surveys$id[i]
```

You can retrieve a list of the questions the survey asked using the `survey_questions` function and the survey `id`.

```{r, eval = FALSE}
questions <- survey_questions(id)
```

This returns a `data.frame` with one row per question with columns for question id, question name, question text, and whether the question was required. This is helpful to have as a reference for when you are looking at the full survey results.

To get the full survey results, run `fetch_survey` with the survey id.

```{r, eval = FALSE}
survey_results <- fetch_survey(id)
```

The survey results table has tons of information in it, not all of which will be relevant depending on your survey. The table has identifying information for the respondents (eg: `ResponseID`, `IPaddress`, `RecipientEmail`, `RecipientFirstName`, etc), much of which will be empty for this survey since it is anonymous. It also has information about the process of taking the survey, such as the `StartDate`, `EndDate`, `Progress`, and `Duration`. Finally, there are the answers to the questions asked, with columns labeled according to the `qname` column in the questions table (eg: Q1, Q2, Q3). Depending on the type of question, some questions might have multiple columns associated with them. We'll have a look at this more closely in a later example. 

#### Question 2 {-}

Let's look at the responses to the second question in the survey, "How long have you been programming?" Remember, the first question was the consent question.

We'll use the `dplyr` and `tidyr` tools we learned earlier to extract the information. Here are the steps:

- `select` the column we want (`Q1`)
- `group_by` and `summarize` the values

```{r, eval = FALSE}
q2 <- survey_results %>% 
    select(Q2) %>% 
    group_by(Q2) %>% 
    summarise(n = n())
```

We can show these results in a table using the `kable` function from the `knitr` package:

```{r, eval = FALSE}
kable(q2)
```

#### Question 3

For question 3, we'll use a similar workflow. For this question, however there are two columns containing survey answers. One contains the answers from the controlled vocabulary, the other contains any free text answers users entered.

To present this information, we'll first show the results of the controlled answers as a plot. Below the plot, we'll include a table showing all of the free text answers for the "other" option.

```{r, eval = FALSE}
q3 <- survey_results %>% 
    select(Q3) %>% 
    group_by(Q3) %>% 
    summarise(n = n())
```

```{r, eval = FALSE}
ggplot(data = q3, mapping = aes(x = Q3, y = n)) +
    geom_col() +
    labs(x = "What language do you currently use most frequently?", y = "Number of reponses") +
    theme_minimal()
```

Now we'll extract the free text responses:

```{r}
q3_text <- survey_results %>% 
    select(Q3_7_TEXT) %>% 
    drop_na() %>% 
    rename(`Other (please indicate)` = Q3_7_TEXT)

kable(q3_text)
```

#### Question 4

The last question is just a free text question, so we can just display the results as is. 

```{r, eval = FALSE}
q4 <- survey_results %>% 
    select(Q4) %>% 
    rename(`What data science tool or language are you most excited to learn next?` = Q4) %>% 
    drop_na()

kable(q4)
```


### Other survey tools

#### Survey Monkey {-}

Similar to Qualtrics and qualtRics, there is an open source R package for working with data in Survey Monkey: [Rmonkey](https://github.com/cloudyr/Rmonkey). Again, this package requires API access to Survey Monkey and documentation on setup is provided within the [Readme](https://github.com/cloudyr/Rmonkey#readme) file. 

Features of RMonkey include the ability to:

1. `createsurvey()` which will create an email collector survey from a template of another survey example
1. `createcollector()` which will create a web collector survey from a template of another survey example
1. `getresponses()` will return responses from a survey
1. List various entities including `surveylist()` `templatelist()` `respondentlist()`

Also like qualtRics this package is open source and community developed. Inspection of the GitHub repository shows that the last updates were made 5 years ago and so the package may not function as intended. 

There are also commercial options available. For example, [cdata](https://www.cdata.com/kb/tech/surveymonkey-jdbc-r.rst) have a driver and R package that enable access to an analysis of Survey Monkey data through R.  

#### Google forms  {-}

Google forms can be a great way to set up surveys, and it is very easy to interact with the results using R. The benefits of using google forms are a simple interface and easy sharing between collaborators, especially when writing the survey instrument.

The downside is that google forms has far fewer features than Qualtrics in terms of survey flow and appearance.

To show how we can link R into our survey workflows, I've set up a simple example survey [here](https://docs.google.com/forms/d/1Yh3IxygzuLXzJvTHl-lskMy7YrQgmeWgr2bEw5gwdIM/edit?usp=sharing). 

I've set up the results so that they are in a new spreadsheet [here:](https://docs.google.com/spreadsheets/d/1CSG__ejXQNZdwXc1QK8dKouxphP520bjUOnZ5SzOVP8/edit?resourcekey#gid=1527662370). To access them, we will use the `googlesheets4` package.

First, open up a new R script and load the `googlesheets4` library:

```{r}
library(googlesheets4)
```

Next, we can read the sheet in using the same URL that you would use to share the sheet with someone else. Right now, this sheet is public

```{r, echo = FALSE}
gs4_deauth()
```


```{r}
responses <- read_sheet("https://docs.google.com/spreadsheets/d/1CSG__ejXQNZdwXc1QK8dKouxphP520bjUOnZ5SzOVP8/edit?usp=sharing")
```

The first time you run this, you should get a popup window in your web browser asking you to confirm that you want to provide access to your google sheets via the tidyverse (googlesheets) package.

My dialog box looked like this:

![](images/gsheets-access.png)

Make sure you click the third check box enabling the Tidyverse API to see, edit, create, and delete your sheets. Note that you will have to tell it to do any of these actions via the R code you write.

When you come back to your R environment, you should have a data frame containing the data in your sheet!

##### Bypassing authentication for public sheets {-}

If you don't want to go through a little interactive dialog every time you read in a sheet, and your sheet is public, you can run the function `gs4_deauth()` to access the sheet as a public user. This is helpful for cases when you want to run your code non-interactively. This is actually how I set it up for this book to build!
