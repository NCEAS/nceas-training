{
  "hash": "9f8017b22600d1c5567601062ddd49ac",
  "result": {
    "markdown": "---\ntitle: \"R Practice: Tidy Data & Joins\"\ntitle-block-banner: true\nexecute:\n  eval: false\nformat:\n  html: \n    code-link: true\n    code-fold: true\n    code-summary: \"Answer\"\n    code-overflow: wrap\n---\n---\nbibliography: book.bib\n---\n\n## Learning Objectives {.unnumbered}\n\n-   Practice joining tables together\n-   Practice identifying primary and foreign keys\n-   Practice using common cleaning and wrangling functions\n\n::: callout-note\n## Acknowledgements\n\nThese exercises are adapted from Allison Horst's EDS 221: Scientific Programming Essentials Course for the Bren School's Master of Environmental Data Science program.\n:::\n\n## About the data {.unnumbered}\n\nThese exercises will be using bird survey data collected from the central Arizona-Phoenix metropolitan area by Arizona State University researchers [@warren2021].\n\n## Exercise: Practice Joins\n\n::: callout-tip\n## Setup\n\n0. Make sure you're in the right project (`training_{USERNAME}`) and use the Git workflow by `Pull`ing to check for any changes in the remote repository (aka repository on GitHub).\n\n1. Create a new Quarto Document. \n    a. Title it \"R Practice: Tidy Data and Joins\". \n    b. Save the file and name it \"r-practice-tidy-data-joins\". \n\n**Note:** Double check that you're in the right project. Where in RStudio can you check where you are?\n\n2.  Load the following libraries at the top of your Quarto Document.\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(readr)\nlibrary(dplyr)\nlibrary(lubridate) # for bonus question\n\n# Quick question: Do you get a message after loading the libraries? What is it telling you? Talk to your neighbor about it or write a note in your qmd.\n```\n:::\n\n3.  Obtain data from the EDI Data Portal [Ecological and social interactions in urban parks: bird surveys in local parks in the central Arizona-Phoenix metropolitan area](https://portal.edirepository.org/nis/mapbrowse?scope=knb-lter-cap&identifier=256&revision=10). Download the following files:\n\n-   `52_pp52_birds_1.csv`\n-   `52_pp52_surveys_1.csv`\n-   `52_pp52_sites_1.csv`\n-   `52_pp52_taxalist_1.csv`\n\n**Note:** It's up to you on how you want to download and load the data! You can either use the download links (obtain by right-clicking the \"Download\" button and select \"Copy Link Address\" for each data entity) or manually download the data and then upload the files to RStudio server.\n\n4. Organize your Quarto Document in a **meaningful** way. Organization is personal - so this is up to you! Consider the different ways we've organized previous files using: headers, bold text, naming code chunks, comments in code chunks. What is most important is organizing and documenting the file so that your future self (or if you share this file with others!) understands it as well as your current self does right now. \n\n5. Use the Git workflow. After you've set up your project and uploaded your data go through the workflow: ```Stage (add) -> Commit -> Pull -> Push```\n    - **Note:** You also want to `Pull` when you first open a project.\n:::\n\n### Read in the data\n\n::: callout-note\n#### Question 1\n\nRead in the data and store the data frames as `bird_observations`, `sites`, `surveys`, and `taxalist` (it should be clear from the raw file names which is which).\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Answer\"}\n# read in data using download links\nbird_observations <- read_csv(\"https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-cap.256.10&entityid=53edaa7a0e083013d9bf20322db1780e\")\nsurveys <- read_csv(\"https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-cap.256.10&entityid=b2466fa5cb5ed7ee1ea91398fc291c59\")\nsites <- read_csv(\"https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-cap.256.10&entityid=81bf72420e69077097fb0790dcdc63a6\")\ntaxalist <- read_csv(\"https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-cap.256.10&entityid=58f863b7e3066e68536a9cacdc7bd58e\")\n\n# read in data from the data directory after manually downloading data \nbird_observations <- read_csv(\"data/52_pp52_birds_1.csv\")\nsurveys <- read_csv(\"data/52_pp52_surveys_1.csv\")\nsites <- read_csv(\"data/52_pp52_sites_1.csv\")\ntaxalist <- read_csv(\"data/52_pp52_taxalist_1.csv\")\n```\n:::\n\n### Get familiar with the data\n\n::: callout-note\n#### Question 2a\n\nWhat functions can you use to explore the data you just read in? Think about which functions we've been using to explore the structure of the data frame, information about columns, unique observations, etc.\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Answer\"}\n# view data in a spreadsheet-style viewer\nView(bird_observations)\n\n# returns dimensions of the dataframe by number of rows and number of cols\ndim(bird_observations)\n\n# returns the top six rows of the dataframe\nhead(bird_observations)\n\n# returns all the columns and some info about the cols\nglimpse(bird_observations)\n\n# similar to glimpse but returns some summary statistics about the cols\nsummary(bird_observations)\n\n# returns column names \nnames(bird_observations)\n\n# returns unique values in a column. In this case we can see all the different bird species IDs\nunique(bird_observations$species_id)\n```\n:::\n\n::: callout-note\n#### Question 2b\n\nWhat are the primary and foreign keys for the tables `bird_observations` and `taxalist`? Recall that a **primary key** is a unique identifier for each observed entity, one per row. And a **foreign key** references to a primary key in another table (linkage).\n\n**Hint:** First identify the primary keys for all the tables, then identify the foreign keys.\n:::\n\n<details>\n\n<summary>Answer</summary>\n\n-   `bird_observations`: Primary key is a compound key made up of `survey_id`, `site_id`, and `species_id`. The foreign key is `species_id`.\n-   `taxalist`: Primary key is `species_id` and does not have a foreign key.\n\n</details>\n\n### Create a subset of `bird_observations`\n\n::: callout-note\n#### Question 3\n\nWrite code to create a subset of `bird_observations` called `birds_subset` that only contains observations for birds with species id `BHCO` and `RWBL`, and from sites with site ID `LI-W` and `NU-C`.\n\n**Hint:** What function do you use to subset data by rows?\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Answer\"}\nbirds_subset <- bird_observations %>% \n  filter(species_id %in% c(\"BHCO\", \"RWBL\")) %>% \n  filter(site_id %in% c(\"LI-W\", \"NU-C\"))\n```\n:::\n\n### Use `left_join()` to merge `birds_subset` with the tables `sites` and `taxalist`\n\n::: callout-note\n#### Question 4a\n\nFirst, answer: what do you expect a `left_join()` between `birds_subset` and `sites` to contain? Write this in your Quarto Document or tell a neighbor.\n:::\n\n<details>\n\n<summary>Answer</summary>\n\nI expect to see all columns and all observations from `birds_subset` and from `sites`, I expect to see the columns `park_code`, `park_district`, `park-name`, `point_code`, `point_location` and `park_acreage` and only observations for `NU-C` and `LI-W` because those are the only `site_id` values in `birds_subset` and in a left join only the observations matching the left table (in this case, `birds_subset` is the left table) will be kept.\n\n</details>\n\n\n::: callout-note\n#### Qustion 4b\n\nUse a left join to update `birds_subset` so that it also includes `sites` information. For each join, include an explicit argument saying which key you are joining by (even if it will just assume the correct one for you). Store the updated data frame as `birds_left`. Make sure to look at the output - is what it contains consistent with what you expected it to contain?\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Answer\"}\n# syntax using pipe\nbirds_left <- birds_subset %>% \n  left_join(y = sites, by = \"site_id\")\n# don't see x = birds_subset here because piping in birds_subset means it automatically assumes birds_subset as x.\n\n# syntax without pipe\nbirds_left <- left_join(x = birds_subset, y = sites, by = \"site_id\")\n```\n:::\n\n### Use `full_join()` to merge `birds_subset` and `sites` tables\n\n::: callout-note\n#### Question 5a\n\nFirst, answer: what do you expect a `full_join()` between `birds_subset` and `sites` to contain? Write this in your Quarto Document or tell a neighbor.\n:::\n\n<details>\n\n<summary>Answer</summary>\n\nI expect to see all columns and all observations from `birds_subset` and all columns and all observations from `sites` to be merged into one data frame because in a full join everything is kept.\n\n</details>\n\n::: callout-note\n#### Questions 5b\n\nWrite code to `full_join()` the `birds_subset` and `sites` data into a new object called `birds_full`. Explicitly include the variable you're joining by. Look at the output. Is it what you expected?\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Answer\"}\n# syntax using pipe\nbirds_full <- birds_subset %>% \n  full_join(y = sites, by = \"site_id\")\n\n# syntax without pipe\nbirds_full <- full_join(x = birds_subset, y = sites, by = \"site_id\")\n```\n:::\n\n\n### Use `inner_join()` to merge `birds_subset` and `taxalist` data\n\n::: callout-note\n#### Question 6a\nFirst, answer: what do you expect an `inner_join()` between `birds_subset` and `taxalist` to contain? Write this in your Quarto Document or tell a neighbor.\n:::\n\n<details>\n\n<summary>Answer</summary>\n\nI expect to only have data merge together based on `species_id` and since there is only `BHCO` and `RWBL` in `birds_subset` then I will only retain data related to those two species. I will also expect to see the columns from `taxalist`: `common_name` and `asu_itis` to be merged into the joined table.\n\n</details>\n\n::: callout-note\n#### Question 6b\nWrite code to `inner_join()` the `birds_subset` and `taxalist`, called `birds_inner.` Include an argument for what variable you'll be joining by. Make sure you check the output.\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Answer\"}\n# syntax using pipe\nbirds_inner <- birds_subset %>% \n  inner_join(y = taxalist, by = \"species_id\")\n\n# syntax without pipe\nbirds_inner <- inner_join(x = birds_subset, y = taxalist, by = \"species_id\" )\n```\n:::\n\n::: callout-note\n#### Question 6c\nWhat would you get if instead of `inner_join()` you'd used `left_join()` for this example? Write code for the left join and check.\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Answer\"}\n# syntax using pipe\nbirds_inner_left <- birds_subset %>% \n  left_join(y = taxalist, by = \"species_id\")\n\n# syntax without pipe\nbirds_inner_left <- left_join(x = birds_subset, y = taxalist, by = \"species_id\")\n```\n:::\n\n::: callout-note\n#### Question 6d\nWhy does that make sense for this scenario? In what case would you expect the outcome to differ from an `inner_join()`? Write this in your Quarto Document or tell a neighbor.\n:::\n\n<details>\n\n<summary>Answer</summary>\n\nYou have the same resulting data set regardless of using `inner_join()` or `left_join()` to merge `bird_subset` and `taxalist`. The reasons for this are:\n\n- `inner_join()` keeps only the rows (observations) that have a matching key across both data sets - here, `species_id` is our key, and the only rows that match across both data sets are those where `species_id` equals `BHCO` or `RWBL`\n\n- `left_join()` keeps all rows from the left table (in our case, the left table is `birds_subset`) and merges on data with matching keys (`species_id`) on the right (here, the right table is `taxalist`). Because our left data set (`birds_subset`) only contains `species_id`s equal to `BHCO` or `RWBL`, only rows with those species will be kept from the right data set (`taxalist`)\n\nYou'd expect the outcome to differ from an `inner_join()` if `birds_subset` contained an observation with a `species_id` that was *not* found in `taxalist`. If there was an observation of a `species_id` in `birds_subset` that was *not* in `taxalist`, then that observation would be kept, and `NA`s would be assigned to the `common_name` and `asu_itis` columns for that observations\n\n</details>\n\n## Exercise: Practice Wrangling & Joining Data\n\n### Wrangle `bird_observations` data and merge the data with all the other tables (`sites`, `surveys`, and `taxalist`)\n\n::: callout-note\n#### Question 7a\nStarting with your object `bird_observations`, rename the `notes` column to `bird_obs_notes` (so this doesn't conflict with `notes` in the `surveys` table).\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Answer\"}\nbird_observations <- bird_observations %>% \n  rename(bird_obs_notes = notes)\n```\n:::\n\n::: callout-note\n#### Question 7b\n\n- Create a subset that contains all observations in the `birds_observations` data frame, \n- then join the `taxalist`, `sites` and `surveys` tables to it, \n- and finally limit to only columns `survey_date`, `common_name`, `park_name`, `bird_count`, and `observer`. \n\n**Hint:** What function do you use to subset data by columns?\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Answer\"}\nbird_obs_subset <- bird_observations %>% \n  full_join(y = taxalist, by = \"species_id\") %>% \n  full_join(y = sites, by = \"site_id\") %>% \n  full_join(y = surveys, by = c(\"site_id\", \"survey_id\")) %>%  \n  select(survey_date, common_name, park_name, bird_count, observer)\n```\n:::\n\n### Explore `observer` data and fix the values within this column so that all values are in the same format\n\n::: callout-note\n#### Question 8a\nContinuing with `bird_obs_subset`, first use `unique()` to see the different unique values in the column `observer`. How many observers are there? Which value is unlike the others?\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Answer\"}\nunique(bird_obs_subset$observer)\n```\n:::\n\n::: callout-note\n#### Question 8b\nReplace \"Josh Burns\" with a format that matches the other observer names. Then use `unique()` again to check your work.\n\n**Hint:** What function do you use when you are making a change to an entire column?\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Answer\"}\nbird_obs_subset <- bird_obs_subset %>% \n  mutate(observer = if_else(condition = observer == \"Josh Burns\", \n                            true = \"J. Burns\", \n                            false = observer))\n\nunique(bird_obs_subset$observer)\n```\n:::\n\n::: callout-important\n## Save your work and use Git\nDon't forget the Git workflow! After you've completed the exercises or reached a significant stopping point, use the workflow: ```Stage (add) -> Commit -> Pull -> Push```\n:::\n\n### Bonus: Use a new package `lubridate` to wrangle the date data and find the total number of birds by park and month\n\n**Hint:** How do you learn about a new function or package?\n\n::: callout-note\n#### Bonus Question(s)\n\n1. Use `lubridate::month()` to add a new column to `bird_obs_subset` called `survey_month`, containing only the month number. Then, convert the month number to a factor (again within `mutate()`).\n\n2. Use `dplyr::relocate()` to move the new `survey_month` column to immediately after the `survey_date` column. You can do this in a separate code chunk, or pipe straight into it from your existing code.\n\n3. Filter to only include parks `Lindo`, `Orme`, `Palomino`, and `Sonrisa`.\n\n4. Find the total number of birds observed by park and month (**Hint:** You can use `group_by()` and `summarize()`).\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Answer\"}\nbird_obs_subset <- bird_obs_subset %>% \n  mutate(survey_month = lubridate::month(survey_date)) %>% \n  mutate(survey_month = as.factor(survey_month)) %>% \n  dplyr::relocate(survey_month, .after = survey_date) %>% \n  filter(park_name %in% c(\"Lindo\", \"Orme\", \"Palomino\", \"Sonrisa\")) %>% \n  group_by(park_name, survey_month) %>% \n  summarize(tot_bird_count_month = n())\n```\n:::\n\nTake a look at your final data frame. Does it give you the outcome you expected? Is it informative? How would you improve this wrangling process?\n\n",
    "supporting": [
      "session_09_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}